# Mapa de Rela√ß√µes entre Clusters de Refatora√ß√£o

Este documento visualiza como os diferentes clusters da refatora√ß√£o se relacionam entre si, suas depend√™ncias e a sequ√™ncia ideal de implementa√ß√£o.

## Vis√£o Geral dos Clusters

1. **Cluster de Arquitetura e Design** (Complexidade: Alta)
   - Extra√ß√£o de classes com responsabilidades √∫nicas
   - Implementa√ß√£o de interfaces para desacoplamento
   - Inje√ß√£o de depend√™ncias para testabilidade

2. **Cluster de Robustez e Tratamento de Erros** (Complexidade: M√©dia) ‚úÖ
   - Sistema de exce√ß√µes personalizadas
   - Tratamento de erros espec√≠ficos
   - Logging detalhado para depura√ß√£o

3. **Cluster de Limpeza de C√≥digo** (Complexidade: Baixa) ‚úÖ
   - Remo√ß√£o de c√≥digo n√£o utilizado
   - Melhoria de legibilidade
   - Documenta√ß√£o de APIs

4. **Cluster de Testes e Valida√ß√£o** (Complexidade: M√©dia)
   - Testes unit√°rios
   - Testes de integra√ß√£o
   - Mocks para servi√ßos externos

5. **Cluster de Revis√£o e Documenta√ß√£o** (Complexidade: Baixa)
   - Documenta√ß√£o de arquitetura
   - Atualiza√ß√£o de README
   - Revis√£o final

## Matriz de Depend√™ncias

A matriz abaixo mostra as depend√™ncias entre os clusters. "X" indica que o cluster da linha depende do cluster da coluna para sua implementa√ß√£o ideal.

|                                   | Arquitetura | Robustez | Limpeza | Testes | Revis√£o |
|-----------------------------------|-------------|----------|---------|--------|---------|
| **Cluster de Arquitetura**        |      -      |    X     |    ‚úì    |        |         |
| **Cluster de Robustez**           |             |     -    |    ‚úì    |        |         |
| **Cluster de Testes**             |      X      |    X     |    ‚úì    |    -   |         |
| **Cluster de Revis√£o**            |      X      |    X     |    ‚úì    |    X   |    -    |

Legenda:
- X: Depend√™ncia forte (o cluster da linha depende do cluster da coluna)
- ‚úì: Cluster j√° conclu√≠do

## Fluxo de Implementa√ß√£o

```mermaid
graph TD
    A[Cluster 3: Limpeza de C√≥digo] -->|Conclu√≠do| B[Cluster 2: Robustez e Tratamento de Erros]
    B -->|Conclu√≠do| C[Cluster 1: Arquitetura e Design]
    C --> D[Cluster 4: Testes e Valida√ß√£o]
    D --> E[Cluster 5: Revis√£o e Documenta√ß√£o]
    
    style A fill:#90EE90,stroke:#006400
    style B fill:#90EE90,stroke:#006400
```

## Impacto das Mudan√ßas entre Clusters

1. **Impacto do Cluster de Arquitetura nos outros clusters**:
   - **Robustez**: A arquitetura limpa facilita o tratamento de erros contextualizado por componente
   - **Testes**: Classes com responsabilidade √∫nica s√£o mais f√°ceis de testar isoladamente
   - **Revis√£o**: Arquitetura clara facilita a documenta√ß√£o e manuten√ß√£o

2. **Impacto do Cluster de Robustez nos outros clusters**:
   - **Arquitetura**: Exce√ß√µes bem definidas ajudam a delimitar responsabilidades
   - **Testes**: Facilita a cria√ß√£o de testes para cen√°rios de erro
   - **Revis√£o**: Melhora a documenta√ß√£o de comportamentos de erro

3. **Impacto do Cluster de Testes nos outros clusters**:
   - **Arquitetura**: Pode revelar problemas de design que exigem refatora√ß√£o
   - **Robustez**: Ajuda a identificar cen√°rios de erro n√£o tratados
   - **Revis√£o**: Serve como documenta√ß√£o viva do comportamento esperado

## Classes a serem Implementadas e suas Rela√ß√µes

```mermaid
classDiagram
    class ChatArceeMCP {
        -ChatHistory history
        -CommandProcessor commandProcessor
        -ChatUI ui
        -ArceeClient client
        -MCPIntegration mcp
        -AirtableIntegration airtable
        +run()
        +send_message()
    }
    
    class ChatHistory {
        -List~Dict~ messages
        +add_message()
        +get_messages()
        +clear()
    }
    
    class CommandProcessor {
        -AirtableIntegration airtable
        +process_commands()
        +process_create_task_command()
        +process_list_tasks_command()
    }
    
    class ChatUI {
        +show_message()
        +show_error()
        +show_model_info()
        +get_input()
    }
    
    ChatArceeMCP --> ChatHistory : usa
    ChatArceeMCP --> CommandProcessor : usa
    ChatArceeMCP --> ChatUI : usa
    ChatArceeMCP --> ArceeClient : usa
    CommandProcessor --> AirtableIntegration : usa
```

## Detalhamento dos Clusters

### Cluster 1: Arquitetura e Design

**Objetivo**: Reestruturar o c√≥digo para melhor separa√ß√£o de responsabilidades e aplica√ß√£o de padr√µes de design.

**Riscos**: Introdu√ß√£o de bugs sutis, quebra de funcionalidade existente.

#### Tarefas:

- [ ] **SRP - Passo 1**: Extrair gerenciamento de hist√≥rico (ChatHistory)
  ```python
  class ChatHistory:
      """Gerencia o hist√≥rico de mensagens do chat"""
      
      def __init__(self, system_instruction=None):
          self.messages = []
          if system_instruction:
              self.add_message("system", system_instruction)
      
      def add_message(self, role, content):
          """Adiciona uma mensagem ao hist√≥rico"""
          self.messages.append({"role": role, "content": content})
      
      def get_messages(self):
          """Retorna uma c√≥pia do hist√≥rico de mensagens"""
          return self.messages.copy()
      
      def clear(self, preserve_system=True):
          """Limpa o hist√≥rico, opcionalmente preservando a mensagem do sistema"""
          system_message = None
          if preserve_system and self.messages and self.messages[0]["role"] == "system":
              system_message = self.messages[0]
          
          self.messages = []
          if system_message:
              self.messages.append(system_message)
  ```

- [ ] **SRP - Passo 2**: Extrair processamento de comandos (CommandProcessor)
  ```python
  class CommandProcessor:
      """Processa comandos especiais no chat"""
      
      def __init__(self, airtable_service):
          self.airtable_service = airtable_service
      
      def process_commands(self, text):
          """Processa todos os comandos especiais no texto"""
          processed_text = text
          processed_text = self.process_create_task_command(processed_text)
          processed_text = self.process_list_tasks_command(processed_text)
          return processed_text
      
      def process_create_task_command(self, text):
          """Processa comandos de cria√ß√£o de tarefas"""
          # L√≥gica extra√≠da do m√©todo original process_special_commands
          # ...
          return processed_text
      
      def process_list_tasks_command(self, text):
          """Processa comandos de listagem de tarefas"""
          # L√≥gica extra√≠da do m√©todo original process_special_commands
          # ...
          return processed_text
      
      def extract_task_parameters(self, match):
          """Extrai e valida par√¢metros de uma tarefa a partir de um match de regex"""
          # L√≥gica para extrair par√¢metros
          # ...
          return params
  ```

- [ ] **SRP - Passo 3**: Extrair interface de usu√°rio (ChatUI)
  ```python
  class ChatUI:
      """Gerencia a interface de usu√°rio do chat"""
      
      def __init__(self):
          self.prompt = "\nüë§ Voc√™: "
      
      def show_welcome_message(self, servers=None):
          """Exibe mensagem de boas-vindas"""
          print("\nü§ñ Chat Interativo com Arcee (modo 'auto') + Integra√ß√£o MCP iniciado!")
          print("   Digite 'sair', 'exit' ou 'quit' para encerrar o chat.")
          print("   Digite 'limpar' ou 'clear' para limpar o hist√≥rico.")
          if servers:
              print(f"   Servidores MCP dispon√≠veis: {', '.join(servers)}\n")
      
      def get_user_input(self):
          """Obt√©m entrada do usu√°rio"""
          return input(self.prompt)
      
      def show_thinking(self):
          """Mostra indicador de processamento"""
          print("\nüîÑ Processando...")
      
      def show_response(self, text):
          """Exibe resposta do assistente"""
          print(f"\nü§ñ Arcee: {text}")
      
      def show_model_info(self, response_data):
          """Exibe informa√ß√µes sobre o modelo utilizado"""
          # L√≥gica extra√≠da do m√©todo original
          # ...
      
      def show_error(self, error_message):
          """Exibe mensagem de erro"""
          print(f"\n‚ùå Erro: {error_message}")
      
      def show_goodbye(self):
          """Exibe mensagem de despedida"""
          print("\nüëã Encerrando chat. At√© a pr√≥xima!")
  ```

- [ ] **SRP - Passo 4**: Refatorar a classe principal (ChatArceeMCP)
  ```python
  class ChatArceeMCP:
      """Implementa√ß√£o de chat interativo com Arcee e MCP"""
      
      def __init__(self, llm_client=None, mcp_integration=None, airtable=None, ui=None):
          # Inje√ß√£o de depend√™ncias
          self.client = llm_client or self._create_default_client()
          self.mcp_integration = mcp_integration or MCPIntegration()
          self.airtable = airtable or AirtableIntegration()
          self.ui = ui or ChatUI()
          self.history = ChatHistory(self._get_system_instruction())
          self.command_processor = CommandProcessor(self.airtable)
          self.available_servers = self.mcp_integration.list_available_servers()
          
      def _create_default_client(self):
          # L√≥gica para criar cliente padr√£o
          # ...
          
      def _get_system_instruction(self):
          # Define instru√ß√£o do sistema
          # ...
          
      def run(self):
          """Executa o loop principal do chat"""
          try:
              self.ui.show_welcome_message(self.available_servers)
              while True:
                  user_input = self.ui.get_user_input()
                  
                  if self._handle_special_input(user_input):
                      continue
                  
                  if not user_input.strip():
                      continue
                  
                  response = self._process_user_message(user_input)
                  if response:
                      self.ui.show_response(response.get('processed_text', response['text']))
                      self.ui.show_model_info(response)
          except KeyboardInterrupt:
              self.ui.show_goodbye()
              
      def _handle_special_input(self, user_input):
          """Trata comandos especiais do usu√°rio"""
          # L√≥gica para comandos como exit, clear, etc
          # ...
          
      def _process_user_message(self, message):
          """Processa mensagem do usu√°rio e obt√©m resposta"""
          # L√≥gica simplificada para enviar mensagem e processar resposta
          # ...
  ```

- [ ] **DIP - Passo 1**: Criar interfaces abstratas
  ```python
  from abc import ABC, abstractmethod

  class LLMClient(ABC):
      """Interface para clientes de modelos de linguagem"""
      
      @abstractmethod
      def generate_content_chat(self, messages):
          """Gera conte√∫do a partir de mensagens de chat"""
          pass

  class MCPService(ABC):
      """Interface para servi√ßos MCP"""
      
      @abstractmethod
      def list_available_servers(self):
          """Lista servidores dispon√≠veis"""
          pass

  class TaskService(ABC):
      """Interface para servi√ßo de tarefas"""
      
      @abstractmethod
      def create_task(self, task_name, description, deadline, status):
          """Cria uma nova tarefa"""
          pass
      
      @abstractmethod
      def list_tasks(self):
          """Lista as tarefas existentes"""
          pass
  ```

- [ ] **DIP - Passo 2**: Adaptar implementa√ß√µes existentes
  ```python
  class ArceeClientAdapter(LLMClient):
      """Adaptador para o cliente Arcee"""
      
      def __init__(self, model="auto"):
          self.client = ArceeClient(model=model)
      
      def generate_content_chat(self, messages):
          return self.client.generate_content_chat(messages)

  class MCPIntegrationAdapter(MCPService):
      """Adaptador para a integra√ß√£o MCP"""
      
      def __init__(self):
          self.integration = MCPIntegration()
      
      def list_available_servers(self):
          return self.integration.list_available_servers()

  class AirtableServiceAdapter(TaskService):
      """Adaptador para o servi√ßo Airtable"""
      
      def __init__(self, api_key=None, base_id=None, table_id=None):
          self.service = AirtableIntegration()
          if api_key:
              self.service.api_key = api_key
          if base_id:
              self.service.base_id = base_id
          if table_id:
              self.service.table_id = table_id
      
      def create_task(self, task_name, description=None, deadline=None, status="Not started"):
          return self.service.create_task(task_name, description, deadline, status)
      
      def list_tasks(self):
          return self.service.list_tasks()
  ```

- [ ] **DIP - Passo 3**: Implementar Factory para cria√ß√£o de servi√ßos
  ```python
  class ServiceFactory:
      """F√°brica para criar inst√¢ncias de servi√ßos"""
      
      @staticmethod
      def create_llm_client(client_type="arcee", **kwargs):
          """Cria cliente LLM baseado no tipo"""
          if client_type.lower() == "arcee":
              return ArceeClientAdapter(**kwargs)
          # Pode ser expandido para suportar outros tipos de cliente
          raise ValueError(f"Tipo de cliente LLM n√£o suportado: {client_type}")
      
      @staticmethod
      def create_mcp_service():
          """Cria servi√ßo MCP"""
          return MCPIntegrationAdapter()
      
      @staticmethod
      def create_task_service(service_type="airtable", **kwargs):
          """Cria servi√ßo de tarefas baseado no tipo"""
          if service_type.lower() == "airtable":
              return AirtableServiceAdapter(**kwargs)
          # Pode ser expandido para suportar outros tipos de servi√ßos
          raise ValueError(f"Tipo de servi√ßo de tarefas n√£o suportado: {service_type}")
  ```

- [ ] **DIP - Passo 4**: Atualizar script principal para usar Factory
  ```python
  def main():
      """Fun√ß√£o principal do script"""
      try:
          # Criar servi√ßos usando Factory
          llm_client = ServiceFactory.create_llm_client(model="auto")
          mcp_service = ServiceFactory.create_mcp_service()
          task_service = ServiceFactory.create_task_service()
          
          # Criar UI
          ui = ChatUI()
          
          # Criar e executar chat
          chat = ChatArceeMCP(llm_client, mcp_service, task_service, ui)
          chat.run()
      
      except Exception as e:
          print(f"‚ùå Erro ao inicializar: {e}")
          sys.exit(1)
  ```

### Cluster 2: Robustez e Tratamento de Erros

**Objetivo**: Melhorar a resili√™ncia do c√≥digo e o tratamento de situa√ß√µes excepcionais.

**Riscos**: Falhas na captura de exce√ß√µes, inconsist√™ncias no tratamento de erros.

#### Tarefas:

- [x] **Sistema de Exce√ß√µes**
  - [x] Criar hierarquia de exce√ß√µes personalizadas (MpccliException como base)
  - [x] Implementar exce√ß√µes espec√≠ficas (LLMApiError, ConfigurationError, etc.)

- [x] **Tratamento de Erros**
  - [x] Refinar try/catch para capturar exce√ß√µes espec√≠ficas
  - [x] Implementar feedback mais detalhado ao usu√°rio
  - [x] Adicionar logging para depura√ß√£o

### Cluster 3: Limpeza de C√≥digo

**Objetivo**: Remover c√≥digo n√£o utilizado e simplificar a base de c√≥digo.

**Riscos**: Remo√ß√£o acidental de c√≥digo necess√°rio.

#### Tarefas:

- [x] **Remo√ß√£o de C√≥digo N√£o Utilizado**
  - [x] Remover o m√©todo get_server_tools()
  - [x] Avaliar e documentar ou remover start_server()
  - [x] Identificar e remover outros m√©todos, importa√ß√µes ou par√¢metros n√£o utilizados

- [x] **Melhoria de Legibilidade**
  - [x] Dividir m√©todo process_special_commands() em fun√ß√µes menores
  - [x] Atualizar documenta√ß√£o de classes e m√©todos
  - [x] Adicionar coment√°rios em √°reas complexas

### Cluster 4: Testes e Valida√ß√£o

**Objetivo**: Garantir a qualidade e estabilidade do c√≥digo refatorado.

**Riscos**: Cobertura de testes insuficiente.

#### Tarefas:

- [ ] **Testes Unit√°rios**
  - [ ] Desenvolver testes para ChatHistory
  - [ ] Desenvolver testes para CommandProcessor
  - [ ] Desenvolver testes para ChatUI
  ```python
  # Exemplo de estrutura para testes unit√°rios
  import unittest
  from unittest.mock import MagicMock, patch
  
  class TestChatHistory(unittest.TestCase):
      def test_add_message(self):
          # ...
      
      def test_clear_with_preserve(self):
          # ...
  
  class TestCommandProcessor(unittest.TestCase):
      def test_process_create_task(self):
          # ...
      
      def test_process_list_tasks(self):
          # ...
  ```

- [ ] **Testes de Integra√ß√£o**
  - [ ] Desenvolver testes que verificam a intera√ß√£o entre componentes
  - [ ] Testar fluxos principais (envio de mensagens, processamento de comandos)
  
- [ ] **Mocks para Servi√ßos Externos**
  - [ ] Desenvolver mocks para ArceeClient
  - [ ] Desenvolver mocks para Airtable API

### Cluster 5: Revis√£o e Documenta√ß√£o

**Objetivo**: Finalizar a documenta√ß√£o e revisar a ader√™ncia √†s regras de desenvolvimento.

**Riscos**: Documenta√ß√£o incompleta ou inconsistente.

#### Tarefas:

- [ ] **Documenta√ß√£o**
  - [ ] Atualizar README.md
  - [ ] Criar guia de contribui√ß√£o
  - [ ] Documentar arquitetura geral

- [ ] **Revis√£o**
  - [ ] Verificar ader√™ncia √†s regras do `.cursorrules`
  - [ ] Validar desempenho ap√≥s mudan√ßas
  - [ ] Incorporar feedback de usu√°rios

## Plano de Implementa√ß√£o (5 Fases)

1. **Fase 1: Refatora√ß√£o Estrutural**
   - [ ] Criar novas classes (ChatHistory, CommandProcessor, ChatUI)
   - [ ] Refatorar ChatArceeMCP para usar essas classes
   - [ ] Implementar interfaces e adapters
   - [ ] Implementar ServiceFactory

2. **Fase 2: Melhorias de Robustez** ‚úÖ
   - [x] Implementar exce√ß√µes personalizadas
   - [x] Refinar tratamento de erros
   - [x] Adicionar logging detalhado

3. **Fase 3: Limpeza e Documenta√ß√£o** ‚úÖ
   - [x] Remover c√≥digo n√£o utilizado
   - [x] Atualizar documenta√ß√£o
   - [x] Adicionar coment√°rios explicativos em √°reas complexas

4. **Fase 4: Testes e Valida√ß√£o**
   - [ ] Desenvolver testes unit√°rios
   - [ ] Desenvolver testes de integra√ß√£o
   - [ ] Validar funcionalidades em ambiente real

5. **Fase 5: Revis√£o Final**
   - [ ] Revisar ader√™ncia √†s regras do `.cursorrules`
   - [ ] Validar performance
   - [ ] Incorporar feedback de usu√°rios

## Pr√≥ximos Passos Detalhados

Considerando as depend√™ncias e o trabalho j√° realizado, recomenda-se a seguinte sequ√™ncia de implementa√ß√£o:

1. **Extra√ß√£o da classe ChatHistory**
   - Implementa√ß√£o isolada e simples
   - N√£o depende de outras refatora√ß√µes pendentes
   - Facilita testes unit√°rios futuros

2. **Extra√ß√£o da classe ChatUI**
   - Implementa√ß√£o isolada para intera√ß√£o com usu√°rio
   - N√£o depende de outras refatora√ß√µes pendentes
   - Permitir√° substitui√ß√£o mais f√°cil caso necess√°rio

3. **Extra√ß√£o da classe CommandProcessor**
   - Depende parcialmente da implementa√ß√£o do sistema de exce√ß√µes (j√° conclu√≠do)
   - Requer a refatora√ß√£o dos m√©todos de processamento de comandos

4. **Refatora√ß√£o da classe principal ChatArceeMCP**
   - Depende da implementa√ß√£o das classes acima
   - Utilizar√° inje√ß√£o de depend√™ncias para usar as novas classes

5. **Implementa√ß√£o de testes unit√°rios**
   - Depende da separa√ß√£o clara de responsabilidades
   - Facilitada pela arquitetura orientada a interfaces

Os Clusters 2 (Robustez) e 3 (Limpeza) j√° foram conclu√≠dos, o que proporciona uma base s√≥lida para a implementa√ß√£o do Cluster 1 (Arquitetura). 


## Mapa de Rela√ß√µes entre Clusters

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       ‚îÇ     ‚îÇ                       ‚îÇ
‚îÇ  1. Reestrutura√ß√£o    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  2. Tratamento de     ‚îÇ
‚îÇ     Arquitetural      ‚îÇ     ‚îÇ     Erros e Robustez  ‚îÇ
‚îÇ                       ‚îÇ     ‚îÇ                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                             ‚îÇ
            ‚ñº                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       ‚îÇ     ‚îÇ  4. ver se o cli na   ‚îÇ
‚îÇ  3. Limpeza de        ‚îÇ     ‚îÇ parte de mcp estamos  ‚îÇ
‚îÇ     C√≥digo            ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ conseguindo buscar    ‚îÇ
‚îÇ                       ‚îÇ     ‚îÇos mesmos mcp do cursor‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                             ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ                       ‚îÇ
             ‚îÇ  5. Planejamento e    ‚îÇ
             ‚îÇ     Gest√£o            ‚îÇ
             ‚îÇ                       ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```